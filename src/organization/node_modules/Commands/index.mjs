import fs from 'fs';
import path from 'path';
import flatten from 'lodash/flatten.js';

import registry from 'registry';

import hyperworldReadline from 'hyperworld-readline';

export default class Commands {

  commands = [];


  constructor(){

  }

  async initialize(){

    const moduleURL = new URL(import.meta.url);
    const dirname = path.dirname(moduleURL.pathname);
    const filePath = path.resolve(dirname+'/node_modules');
    const fileListing = (await fs.promises.readdir(filePath, {withFileTypes:true}));
    const classPaths = fileListing
    .filter(dirEnt=>dirEnt.isDirectory())
    .map(dirEnt=>dirEnt.name)
    .filter(name=>name.match(/^[A-Z]/))
    for( const location of classPaths ){
     try{
       this.commands.push(new (await import(location)).default)
     }catch(e){
       console.error(`Error in dynamically loaded command module: ${path.resolve(dirname+'/node_modules')+'/'+location}`);
       console.error(e);
       throw e;
     }
    }

    console.dir(this.commands);
    registry.commands = this;
   }



  async input({session, text}){
    const screen = session.user.screen;
    const {command, argument} = hyperworldReadline(text);

    let matched = false;
    for(const entry of this.commands){
      if(entry.match({session, text, command, argument})){

        matched = true;
        await entry.execute({session, text, command, argument});
      }
    }
    if(!matched){
      await screen.warning(`Input "${text}" not understood, type in 'help' for a list of commands.`)
    }
  }

  async completions(){
    const response = flatten(this.commands.map(({aliases})=>aliases)).filter(c=>c.length>1);
    //
    // // this helps with navigation
    // const {origin, locations} = this.getPossibleLocationNames();
    // for (const location of locations){
    //   response.push(`enter ${location}`);
    // }
    // if((origin)&&(origin!=this.location.meta.label)) response.push(`enter ${origin}`);
    //
    // // TODO: restore asistant assistance
    // // help with assistant conversations
    // // const assistant = await radio.request('assistant');
    // // for (const conversation of assistant.getPossibleAssistantConversationNames()){
    // //     response.push(`assistant ${conversation}`);
    // // }
    //

    return response.sort()

  }



}
