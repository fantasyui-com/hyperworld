import fs from 'fs';
import path from 'path';
import flatten from 'lodash/flatten.js';

import registry from 'registry';

import hyperworldReadline from 'hyperworld-readline';

export default class Commands {

  commands = [];


  constructor(){

  }

  async initialize(){

    const moduleURL = new URL(import.meta.url);
    const dirname = path.dirname(moduleURL.pathname);
    const filePath = path.resolve(dirname+'/node_modules');
    const fileListing = (await fs.promises.readdir(filePath, {withFileTypes:true}));
    const classPaths = fileListing
    .filter(dirEnt=>dirEnt.isDirectory())
    .map(dirEnt=>dirEnt.name)
    .filter(name=>name.match(/^[A-Z]/))
    for( const location of classPaths ){
       this.commands.push(new (await import(location)).default)
    }
    // console.dir(this.commands);
    registry.commands = this;
   }

  async getActionCompletions(){
    const response = flatten(this.actions.map(({names})=>names));

    // this helps with navigation
    const {origin, locations} = this.getPossibleLocationNames();
    for (const location of locations){
      response.push(`enter ${location}`);
    }
    if((origin)&&(origin!=this.location.meta.label)) response.push(`enter ${origin}`);

    // TODO: restore asistant assistance
    // help with assistant conversations
    // const assistant = await radio.request('assistant');
    // for (const conversation of assistant.getPossibleAssistantConversationNames()){
    //     response.push(`assistant ${conversation}`);
    // }

    //console.log(response)
    return response.sort()

  }

  async input({session, text}){
    const screen = session.user.screen;
    const {command, argument} = hyperworldReadline(text);

    let matched = false;
    for(const entry of this.commands){
      if(entry.match({session, text, command, argument})){

        matched = true;
        await entry.execute({session, text, command, argument});
      }
    }
    if(!matched){
      await screen.warning(`Input "${text}" not understood...`)
    }
  }





}
